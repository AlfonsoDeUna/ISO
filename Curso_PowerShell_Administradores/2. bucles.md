# Guía de Bucles en PowerShell

> Aprende a usar `for`, `while`, `foreach` y cómo trabajar con **arrays** en PowerShell mediante ejemplos prácticos.

---

## Arrays en PowerShell

Un **array** es una variable que almacena múltiples valores. En PowerShell se crean con `@()` o simplemente asignando valores separados por comas.

```powershell
# Crear arrays
$frutas = @("manzana", "naranja", "pera", "uva")
$numeros = @(10, 20, 30, 40, 50)

# También válido (sin @())
$colores = "rojo", "verde", "azul"

# Acceder a elementos por índice (empieza en 0)
$frutas[0]    # → manzana
$frutas[2]    # → pera
$frutas[-1]   # → uva (último elemento)

# Longitud del array
$frutas.Length   # → 4
$frutas.Count    # → 4 (equivalente)

# Modificar un elemento
$frutas[1] = "limón"

# Añadir elementos (crea un nuevo array)
$frutas += "melón"

# Mostrar todos los elementos
$frutas
```

### Tipos de arrays útiles

```powershell
# Array vacío
$vacio = @()

# Array de números
$notas = @(7, 5, 9, 8, 6, 10, 4)

# Array de objetos mixtos
$mixto = @("texto", 42, $true, 3.14)

# Array multidimensional
$matriz = @(
    @(1, 2, 3),
    @(4, 5, 6),
    @(7, 8, 9)
)
$matriz[1][2]  # → 6
```

---

## Bucle `for`

El bucle `for` se usa cuando **sabes cuántas veces** quieres repetir una acción. Ideal cuando necesitas trabajar con el **índice** del array.

### Sintaxis

```powershell
for (<inicio>; <condición>; <incremento>) {
    # bloque de código
}
```

### Ejemplos básicos

```powershell
# Contar del 0 al 4
for ($i = 0; $i -lt 5; $i++) {
    Write-Host "Iteración: $i"
}

# Contar del 1 al 10
for ($i = 1; $i -le 10; $i++) {
    Write-Host $i
}

# Contar hacia atrás
for ($i = 10; $i -ge 0; $i--) {
    Write-Host $i
}

# De 2 en 2
for ($i = 0; $i -le 20; $i += 2) {
    Write-Host $i
}
```

### `for` con arrays

```powershell
$frutas = @("manzana", "naranja", "pera", "uva")

for ($i = 0; $i -lt $frutas.Length; $i++) {
    Write-Host "Índice $i → $($frutas[$i])"
}
# → Índice 0 → manzana
# → Índice 1 → naranja
# → Índice 2 → pera
# → Índice 3 → uva
```

```powershell
# Modificar elementos durante el recorrido
$notas = @(4, 7, 5, 9, 3, 8)

for ($i = 0; $i -lt $notas.Length; $i++) {
    if ($notas[$i] -lt 5) {
        $notas[$i] = 5   # Nota mínima de 5
    }
}
$notas   # → 5, 7, 5, 9, 5, 8
```

```powershell
# Recorrer dos arrays en paralelo
$alumnos = @("Ana", "Luis", "Eva")
$notas   = @(8, 6, 9)

for ($i = 0; $i -lt $alumnos.Length; $i++) {
    Write-Host "$($alumnos[$i]) → $($notas[$i])"
}
```

### Operadores de comparación en PowerShell

| Operador | Significado |
|----------|-------------|
| `-lt` | Menor que (`<`) |
| `-le` | Menor o igual (`<=`) |
| `-gt` | Mayor que (`>`) |
| `-ge` | Mayor o igual (`>=`) |
| `-eq` | Igual (`==`) |
| `-ne` | Distinto (`!=`) |

---

## Bucle `while`

El bucle `while` se repite **mientras una condición sea verdadera**. Se usa cuando **no sabes de antemano** cuántas iteraciones habrá.

### Sintaxis

```powershell
while (<condición>) {
    # bloque de código
}
```

### Ejemplos básicos

```powershell
# Contador simple
$i = 0
while ($i -lt 5) {
    Write-Host "Contador: $i"
    $i++   # ATENCION: Nunca olvides actualizar la variable
}
```

```powershell
# Menú interactivo
$opcion = ""
while ($opcion -ne "s") {
    Write-Host "¿Salir? (s/n)"
    $opcion = Read-Host
}
Write-Host "Hasta luego"
```

```powershell
# Validación de entrada
$numero = -1
while ($numero -lt 0 -or $numero -gt 10) {
    $numero = [int](Read-Host "Introduce un número entre 0 y 10")
}
Write-Host "Número válido: $numero"
```

### `while` con arrays

```powershell
$frutas = @("manzana", "naranja", "pera")
$i = 0

while ($i -lt $frutas.Length) {
    Write-Host $frutas[$i]
    $i++
}
```

### `do...while` — ejecuta al menos una vez

Con `while` normal, si la condición es falsa desde el inicio, el bloque **no se ejecuta**. Con `do...while` se ejecuta **siempre al menos una vez**.

```powershell
# do...while
$i = 0
do {
    Write-Host "Ejecutando... $i"
    $i++
} while ($i -lt 3)
```

```powershell
# Caso práctico: pedir contraseña hasta que sea correcta
$intentos = 0
do {
    $pass = Read-Host "Introduce la contraseña" -AsSecureString
    $intentos++
} while ($pass.Length -lt 8 -and $intentos -lt 3)
```

> **Riesgo de bucle infinito**: si la condición nunca se vuelve `$false`, el programa se cuelga. Pulsa `Ctrl+C` para interrumpirlo.

---

## Bucle `foreach`

El bucle `foreach` recorre **directamente los elementos** de un array o colección sin usar índices. Es el más legible y expresivo de los tres.

### Sintaxis

```powershell
foreach ($elemento in $coleccion) {
    # bloque de código
}
```

### Ejemplos básicos

```powershell
$frutas = @("manzana", "naranja", "pera", "uva")

foreach ($fruta in $frutas) {
    Write-Host $fruta
}
# → manzana
# → naranja
# → pera
# → uva
```

```powershell
# Con condición dentro
$notas = @(7, 5, 9, 3, 8, 4, 6)

foreach ($nota in $notas) {
    if ($nota -ge 5) {
        Write-Host "$nota → APROBADO"
    } else {
        Write-Host "$nota → SUSPENSO"
    }
}
```

```powershell
# Acumular valores
$notas = @(7, 5, 9, 8, 6)
$total = 0

foreach ($nota in $notas) {
    $total += $nota
}

$media = $total / $notas.Length
Write-Host "Media: $media"
```

### `ForEach-Object` con pipeline (`|`)

En PowerShell también puedes usar `ForEach-Object` junto con el pipeline, lo que es muy potente para procesar objetos del sistema.

```powershell
# Equivalente al foreach anterior usando pipeline
@(7, 5, 9, 8, 6) | ForEach-Object {
    Write-Host "Nota: $_"   # $_ representa el elemento actual
}
```

```powershell
# Listar procesos y mostrar su nombre
Get-Process | ForEach-Object {
    Write-Host "Proceso: $($_.Name) — PID: $($_.Id)"
}
```

```powershell
# Recorrer archivos de una carpeta
Get-ChildItem "C:\Users" | ForEach-Object {
    Write-Host $_.Name
}
```

### Diferencia entre `foreach` y `ForEach-Object`

| Característica | `foreach` | `ForEach-Object` (`%`) |
|----------------|-----------|------------------------|
| Uso | Con arrays en variable | Con pipeline (`\|`) |
| Variable elemento | `$elemento` | `$_` |
| Velocidad | Más rápido | Más flexible |
| Uso típico | Arrays locales | Cmdlets y objetos del sistema |

---

## Comparativa: ¿cuándo usar cada uno?

| Situación | Bucle recomendado |
|-----------|-------------------|
| Repetir exactamente N veces | `for` |
| Necesitas el índice del array | `for` |
| Modificar elementos por posición | `for` |
| Recorrer dos arrays en paralelo | `for` |
| Condición dinámica, fin incierto | `while` |
| Esperar entrada del usuario | `while` |
| Ejecutar al menos una vez | `do...while` |
| Recorrer todos los elementos limpiamente | `foreach` |
| Procesar salida de cmdlets | `ForEach-Object` + pipeline |

---

## Ejercicio práctico — Gestión de notas

Dado este array de notas, realiza las mismas operaciones con los tres bucles:

```powershell
$notas = @(7, 5, 9, 8, 3, 10, 4, 6)
```

**Calcular la media con `for`:**
```powershell
$total = 0
for ($i = 0; $i -lt $notas.Length; $i++) {
    $total += $notas[$i]
}
$media = $total / $notas.Length
Write-Host "Media (for): $media"
```

**Calcular la media con `while`:**
```powershell
$total = 0
$i = 0
while ($i -lt $notas.Length) {
    $total += $notas[$i]
    $i++
}
$media = $total / $notas.Length
Write-Host "Media (while): $media"
```

**Calcular la media con `foreach`:**
```powershell
$total = 0
foreach ($nota in $notas) {
    $total += $nota
}
$media = $total / $notas.Length
Write-Host "Media (foreach): $media"
```

> Los tres producen el mismo resultado. Elige `foreach` cuando no necesitas el índice, es más legible y menos propenso a errores.

---

## Control de flujo dentro de bucles

```powershell
# break — sale del bucle inmediatamente
for ($i = 0; $i -lt 10; $i++) {
    if ($i -eq 5) { break }
    Write-Host $i
}
# → 0, 1, 2, 3, 4

# continue — salta a la siguiente iteración
for ($i = 0; $i -lt 10; $i++) {
    if ($i % 2 -eq 0) { continue }   # Salta los pares
    Write-Host $i
}
# → 1, 3, 5, 7, 9

# Ejemplo real: buscar un elemento y parar
$alumnos = @("Ana", "Luis", "Eva", "Marcos", "Sofía")
$buscar  = "Eva"

foreach ($alumno in $alumnos) {
    if ($alumno -eq $buscar) {
        Write-Host "¡Encontrado: $alumno!"
        break
    }
}
```

| Palabra clave | Efecto |
|---------------|--------|
| `break` | Sale del bucle inmediatamente |
| `continue` | Salta al siguiente ciclo |
| `return` | Sale de la función completa |
| `exit` | Termina el script |

---
